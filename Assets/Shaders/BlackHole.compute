
#pragma kernel CSMain

RWTexture2D<float4> g_Output;

TextureCube<float4> g_EnvTex;
SamplerState sampler_g_EnvTex;

Texture2D<float4> g_AccretionDiskGradient;
SamplerState my_linear_clamp_sampler;

Texture2D<float3> g_AccretionDiskTex;
SamplerState sampler_g_AccretionDiskTex;
float g_AccretionDiskSpeed;

float g_Zoom;
float g_AspectRatio;
float g_Time;

uint g_CameraResX;
uint g_CameraResY;

float3 g_CameraPos;

// Miller's Planet is outside the accretion disk 
float3 g_PlanetPosition;
#define kPlanetSize 1.0f

Texture2D<float3> g_PlanetTex;

// Unity built-in
float4x4 unity_CameraToWorld;

// Here we simulate a theoretical Schwarzschild black hole. This is a uncharged, non-rotating, spherically symmetric mass.
// In reality, all (Kerr) black holes rotate slower or faster. 
// The initial spin rate of a black hole is caused by the conservation of the residual angular momentum of the colapsed stellar core. 
// After that, the spin rate can change dramatically.

// For non-rotating black holes, the Schwarzschild radius and the event horizon are the same (Rs = 2*G*M/c^2)
// For Earth this would be 9 mm and for the biggest known black holes this is 194 billion km.
#define kRs 10.0f

// The larger the kRs, the larger kMaxSteps or kStepSize should be
// kStepSize is the integration step (dt)
#define kStepSize 0.5f
#define kMaxSteps 300

// In this simulation, the accretion disk is "artificially" generated for art purposes only and for better observing the gravitational lens effect.
#define kAccretionStart 20.0f
#define kAccretionEnd 70.0f

#define PI 3.141592653f

float3 GetAcceleration(float3 pos, float h2)
{    
    float r = length(pos);
    float r2 = r * r;
    float r5 = r2 * r2 * r;
    return pos * (-1.5 * kRs * h2 / r5);
}

float RaySphereIntersect(float3 rayOrig, float3 rayDir, float3 spherePos, float radius)
{
    rayOrig = rayOrig - spherePos;
    float a = dot(rayDir, rayDir);
    float b = 2 * dot(rayOrig, rayDir);
    float c = dot(rayOrig, rayOrig) - radius * radius;
    float delta2 = b * b - 4 * a * c;
    float t = -1;

    if (delta2 >= 0)
    {
        float t0 = (-b + sqrt(delta2)) / (2 * a);
        float t1 = (-b - sqrt(delta2)) / (2 * a);

        // Get the smallest root larger than 0 (t is in object space);
        t = max(t0, t1);

        if (t0 >= 0)
            t = min(t, t0);

        if (t1 >= 0)
            t = min(t, t1);
    }

    return t;
}

void SampleAccretionDisk(float3 pos, float3 prevPos, inout float3 color, inout float transmission)
{     
    // Check if we crossed y = 0 plane
    // If signs are the same it means the position are on the same side of the plane y = 0)
    if (pos.y * prevPos.y > 0)
        return;
    
    // Calculate t where y is 0
    // Linear interpolation: 0 = prevPos.y + t * (pos.y - prevPos.y) -> t = -prevPos.y / (pos.y - prevPos.y)
    float dY = pos.y - prevPos.y;
            
    // Avoid dividing by 0?
    if (abs(dY) < 1e-6f)
        return;
    
    float t = -prevPos.y / dY;

    // Find the intersection point
    float3 hitPoint = prevPos + (pos - prevPos) * t;
    float hitDist = length(hitPoint);

    // Check if the intersection is outside the accretion disk bounds
    if (hitDist < kAccretionStart || hitDist > kAccretionEnd)
        return;
   
    // Get a radial v coordinate. Map v between 0.0 (kAccretionStart) and 1.0 (kAccretionEnd)
    float v = (hitDist - kAccretionStart) / (kAccretionEnd - kAccretionStart);
    
    float4 diskColorGradient = g_AccretionDiskGradient.SampleLevel(my_linear_clamp_sampler, float2(v, 0), 0);
    
    // Get an u coordinate between 0 and 1 from the azimuthal angle of the Schwarzschild coords -PI < phi < PI
    float u = 0.5 + atan2(hitPoint.z, hitPoint.x) / (2 * PI);
            
    float2 uv = float2(g_AccretionDiskSpeed + u, v);
    
    float3 acreetionTex = g_AccretionDiskTex.SampleLevel(sampler_g_AccretionDiskTex, uv, 0);
    
    acreetionTex.rgb *= diskColorGradient.rgb;

    float alpha = diskColorGradient.a;
    alpha *= dot(float3(0.299f, 0.587f, 0.114f), acreetionTex);
    
    float transparency = saturate(alpha);

    color += acreetionTex.rgb * transparency * transmission;
    transmission *= (1 - transparency);
}

void SampleMillersPlanet(float3 pos, float3 prevPos, inout float3 color, inout float transmission)
{
    float3 rayDir = pos - prevPos;
    float rayDirLength = length(rayDir);
 
    // Quick test
    if (dot(pos - g_PlanetPosition, pos - g_PlanetPosition) > (kPlanetSize + rayDirLength) * (kPlanetSize + rayDirLength))
        return;

    rayDir = rayDir / rayDirLength;
        
    float t = RaySphereIntersect(prevPos, rayDir, g_PlanetPosition, kPlanetSize);

    if (t == -1)
        return;
    
    float3 worldSpacePos = prevPos + rayDir * t;
    float3 localSpacePos = worldSpacePos - g_PlanetPosition;
    float3 normal = normalize(localSpacePos);
            
    // Compute some fake lighting
    float3 lightColor = float3(1.0f, 0.4f, 0.1f);
    
    lightColor *= max(0, dot(normal, -normalize(g_PlanetPosition)));
    
    float u = 0.5 + atan2(normal.z, normal.x) / (2 * PI);
    float v = 1 - acos(normal.y) / PI;
    
    float3 planetColor = g_PlanetTex.SampleLevel(my_linear_clamp_sampler, float2(u, v), 0);

    color += planetColor * lightColor * transmission;

    // The planet is opaque
    transmission = 0;
}

[numthreads(8, 8, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= g_CameraResX || id.y >= g_CameraResY)
        return;
    
    uint2 launchIndex = uint2(id.x, g_CameraResY - id.y - 1);
    uint2 launchDim = uint2(g_CameraResX, g_CameraResY);

    // Shoot rays through the center of a pixel.
    float2 frameCoord = launchIndex + float2(0.5, 0.5);    

    float2 ndcCoords = frameCoord / float2(launchDim.x - 1, launchDim.y - 1);

    // Transform in [-1, 1] and apply perspective.
    ndcCoords = ndcCoords * 2 - float2(1, 1);
    ndcCoords = ndcCoords * g_Zoom;

    // Get a ray in view space.
    float3 viewDirection = normalize(float3(ndcCoords.x * g_AspectRatio, ndcCoords.y, 1));

    // Rotate the ray from view space to world space.
    float3 rayDirection = mul((float3x3) unity_CameraToWorld, viewDirection);
    
    float3 pos = g_CameraPos;

    float3 vel = rayDirection;

    // Precalculate the angular momentum which is conserved (constant) during integration
    float3 h = cross(pos, vel);
    float h2 = dot(h, h);

    float3 prevPos = pos;

    // Compute next position: x_1
    pos = prevPos + vel * kStepSize + 0.5f * GetAcceleration(pos, h2) * kStepSize * kStepSize;
    
    float transmission = 1.0f;
    
    float3 color = float3(0, 0, 0);

    // Calculate the trajectory of the photon around the black hole
    // Use basic Stormer-Verlet integration where the current acceleration depends on position only. https://en.wikipedia.org/wiki/Verlet_integration#Basic_St%C3%B8rmer%E2%80%93Verlet
    // Angular momentum is conserved, so it's constant during integration
    for (uint i = 0; i < kMaxSteps; i++)
    {
        float r2 = dot(pos, pos);
    
        // Photon crossed the event horizon
        if (r2 < kRs * kRs)
        {
            g_Output[launchIndex] = float4(color, 1);
            return;
        }
        
        SampleAccretionDisk(pos, prevPos, color, transmission);
        
        // I'm getting inspiration from the Interstellar movie so let's generate a procedural planet ouside the accretion disk
        // Miller's Planet is the fictional water world in the movie Interstellar
        SampleMillersPlanet(pos, prevPos, color, transmission);
        
        // The color is "opaque" so no need to continue the integration
        if (transmission < 0.005f)
        {
            g_Output[launchIndex] = float4(color, 1);
            return;
        }
    
        // Compute x_(n+1) from Stormer-Verlet integration
        float3 nextPos = 2 * pos - prevPos + GetAcceleration(pos, h2) * kStepSize * kStepSize;

        prevPos = pos;
    
        pos = nextPos;
    }
   
    color += g_EnvTex.SampleLevel(sampler_g_EnvTex, pos - prevPos, 0).rgb * transmission;
     
    g_Output[launchIndex] = float4(color, 1);

}
