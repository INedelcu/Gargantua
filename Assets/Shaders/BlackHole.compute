
#pragma kernel CSMain

RWTexture2D<float4> g_Output;

TextureCube<float4> g_EnvTex;
SamplerState sampler_g_EnvTex;

Texture2D<float4> g_AccretionDiskGradient;
SamplerState my_point_clamp_sampler;

float g_Zoom;
float g_AspectRatio;

uint g_CameraResX;
uint g_CameraResY;

float3 g_CameraPos;

// Unity built-in
float4x4 unity_CameraToWorld;

// Here we simulate a theoretical Schwarzschild black hole. This is a uncharged, non-rotating, spherically symmetric mass.
// In reality, all (Kerr) black holes rotate slower or faster. 
// The initial spin rate of a black hole is caused by the conservation of the residual angular momentum of the colapsed stellar core. 
// After that, the spin rate can change dramatically.

// For non-rotating black holes, the Schwarzschild radius and the event horizon are the same (Rs = 2*G*M/c^2)
// For Earth this would be 9 mm and for the biggest known black holes this is 194 billion km.
static float kRs = 10.0;

// The larger the kRs, the larger kMaxSteps or kStepSize should be
// kStepSize is the integration step (dt)
static float kStepSize = 0.5;
static int kMaxSteps = 300;

// In this simulation, the accretion disk is "artificially" generated for art purposes only and for better observing the gravitational lens effect.
static float kAccretionStart = 20.0;
static float kAccretionEnd = 60.0;

float3 GetAcceleration(float3 pos, float h2)
{
    float r2 = dot(pos, pos);
    float r5 = pow(r2, 2.5);
    return pos * (-1.5 * kRs * h2 / r5);
}

[numthreads(8, 8, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= g_CameraResX || id.y >= g_CameraResY)
        return;
    
    uint2 launchIndex = uint2(id.x, g_CameraResY - id.y - 1);
    uint2 launchDim = uint2(g_CameraResX, g_CameraResY);

    // Shoot rays through the center of a pixel.
    float2 frameCoord = launchIndex + float2(0.5, 0.5);    

    float2 ndcCoords = frameCoord / float2(launchDim.x - 1, launchDim.y - 1);

    // Transform in [-1, 1] and apply perspective.
    ndcCoords = ndcCoords * 2 - float2(1, 1);
    ndcCoords = ndcCoords * g_Zoom;

    // Get a ray in view space.
    float3 viewDirection = normalize(float3(ndcCoords.x * g_AspectRatio, ndcCoords.y, 1));

    // Rotate the ray from view space to world space.
    float3 rayDirection = mul((float3x3) unity_CameraToWorld, viewDirection);
    
    float3 pos = g_CameraPos;

    float3 vel = rayDirection;

    // Precalculate the angular momentum which is conserved (constant) during integration
    float3 h = cross(pos, vel);
    float h2 = dot(h, h);

    float3 prevPos = pos;

    // Compute next position: x_1
    pos = prevPos + vel * kStepSize + 0.5f * GetAcceleration(pos, h2) * kStepSize * kStepSize;
    
    float transmission = 1.0f;
    
    float3 col = float3(0, 0, 0);

    // Calculate the trajectory of the photon around the black hole
    // Use basic Stormer-Verlet integration where the current acceleration depends on position only. https://en.wikipedia.org/wiki/Verlet_integration#Basic_St%C3%B8rmer%E2%80%93Verlet
    // Angular momentum is conserved, so it's constant during integration
    for (int i = 0; i < kMaxSteps; i++)
    {
        float r2 = dot(pos, pos);
    
        // Photon crossed the event horizon
        if (r2 < kRs * kRs)
        {
            g_Output[launchIndex] = float4(col, 1);
            return;
        }
        
        // Accretion disk logic
        // Check if we crossed y = 0 plane
        if (pos.y * prevPos.y <= 0)
        {
            // Calculate t where y is 0
            // Linear interpolation: 0 = prevPos.y + t * (pos.y - prevPos.y) -> t = -prevPos.y / (pos.y - prevPos.y)
            float dY = pos.y - prevPos.y;
            
            // Avoid dividing by 0?
            if (abs(dY) > 1e-6f)
            {
                float t = -prevPos.y / dY;

                // Find the intersection point
                float3 hitPoint = prevPos + (pos - prevPos) * t;
                float hitDist = length(hitPoint);

                // Check if this hit is within the accretion disk bounds
                if (hitDist > kAccretionStart && hitDist < kAccretionEnd)
                {
                     // Normalize u between 0.0 (kAccretionStart) and 1.0 (kAccretionEnd)
                    float u = (hitDist - kAccretionStart) / (kAccretionEnd - kAccretionStart);
                    float4 diskColor = g_AccretionDiskGradient.SampleLevel(my_point_clamp_sampler, float2(u, 0), 0);
                    float transparency = diskColor.a;
                    col += diskColor.rgb * transparency * transmission;
                    transmission *= (1 - transparency);
                }
            }
        }
    
        // Compute x_(n+1)
        float3 nextPos = 2 * pos - prevPos + GetAcceleration(pos, h2) * kStepSize * kStepSize;

        prevPos = pos;
    
        pos = nextPos;
    }
   
    col += g_EnvTex.SampleLevel(sampler_g_EnvTex, normalize(pos - prevPos), 0).rgb * transmission;
     
    g_Output[launchIndex] = float4(col, 1);

}
